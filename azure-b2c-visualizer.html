<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Azure B2C Policy Visualizer</title>
  
  <!-- React and ReactDOM dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  
  <!-- Babel for JSX transpilation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.20.7/babel.min.js"></script>
  
  <!-- D3.js for visualization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.2/d3.min.js"></script>
  
  <style>
    /* Base styles */
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #f5f5f5;
    }
    
    #root {
      min-height: 100vh;
      padding: 1rem;
    }
    
    /* Tailwind-like utility classes */
    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .flex-col { flex-direction: column; }
    .space-y-2 > * + * { margin-top: 0.5rem; }
    .space-y-4 > * + * { margin-top: 1rem; }
    .space-y-6 > * + * { margin-top: 1.5rem; }
    .space-x-2 > * + * { margin-left: 0.5rem; }
    .space-x-4 > * + * { margin-left: 1rem; }
    .p-2 { padding: 0.5rem; }
    .p-4 { padding: 1rem; }
    .p-6 { padding: 1.5rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mr-2 { margin-right: 0.5rem; }
    .w-full { width: 100%; }
    .max-w-6xl { max-width: 72rem; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .text-sm { font-size: 0.875rem; }
    .text-lg { font-size: 1.125rem; }
    .text-xl { font-size: 1.25rem; }
    .text-2xl { font-size: 1.5rem; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .text-white { color: white; }
    .text-gray-500 { color: #6b7280; }
    .text-gray-600 { color: #4b5563; }
    .text-gray-800 { color: #1f2937; }
    .text-indigo-100 { color: #e0e7ff; }
    .text-red-700 { color: #b91c1c; }
    .bg-white { background-color: white; }
    .bg-gray-50 { background-color: #f9fafb; }
    .bg-gray-200 { background-color: #e5e7eb; }
    .bg-gray-300 { background-color: #d1d5db; }
    .bg-gray-600 { background-color: #4b5563; }
    .bg-gray-700 { background-color: #374151; }
    .bg-red-100 { background-color: #fee2e2; }
    .bg-indigo-600 { background-color: #4f46e5; }
    .bg-indigo-700 { background-color: #4338ca; }
    .hover\:bg-gray-300:hover { background-color: #d1d5db; }
    .hover\:bg-gray-700:hover { background-color: #374151; }
    .hover\:bg-indigo-700:hover { background-color: #4338ca; }
    .rounded { border-radius: 0.25rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
    .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
    .border-l-4 { border-left-width: 4px; }
    .border-red-500 { border-color: #ef4444; }
    .hidden { display: none; }
    .overflow-auto { overflow: auto; }
    .gap-2 { gap: 0.5rem; }
    .flex-wrap { flex-wrap: wrap; }
    .transform { transform-origin: center; }
    .origin-center { transform-origin: center; }
    
    /* Component-specific styles */
    .journey-visualization {
      width: 100%;
      overflow: auto;
      position: relative;
    }
    
    .journey-visualization svg {
      display: block;
      margin: 0 auto;
      min-width: 800px;
    }

    .journey-visualization .node:hover {
      cursor: pointer;
    }
    
    .journey-visualization .node:hover circle {
      filter: brightness(90%);
    }
    
    .journey-visualization .node-label {
      pointer-events: none;
    }
    
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    // Define custom icon components since Lucide is not available
    const IconComponents = {
      Upload: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      ),
      Download: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" y1="15" x2="12" y2="3" />
        </svg>
      ),
      RefreshCw: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M23 4v6h-6" />
          <path d="M1 20v-6h6" />
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" />
        </svg>
      ),
      ZoomIn: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <circle cx="11" cy="11" r="8" />
          <line x1="21" y1="21" x2="16.65" y2="16.65" />
          <line x1="11" y1="8" x2="11" y2="14" />
          <line x1="8" y1="11" x2="14" y2="11" />
        </svg>
      ),
      ZoomOut: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <circle cx="11" cy="11" r="8" />
          <line x1="21" y1="21" x2="16.65" y2="16.65" />
          <line x1="8" y1="11" x2="14" y2="11" />
        </svg>
      ),
      FitWidth: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
          <line x1="9" y1="3" x2="9" y2="21" />
          <line x1="15" y1="3" x2="15" y2="21" />
          <line x1="3" y1="9" x2="21" y2="9" />
          <line x1="3" y1="15" x2="21" y2="15" />
        </svg>
      )
    };
    
    // Azure B2C Policy Visualizer Component
    const AzureB2CPolicyVisualizer = () => {
      const [xmlContent, setXmlContent] = React.useState('');
      const [policyData, setPolicyData] = React.useState(null);
      const [activeJourney, setActiveJourney] = React.useState(null);
      const [userJourneys, setUserJourneys] = React.useState([]);
      const [isLoading, setIsLoading] = React.useState(false);
      const [error, setError] = React.useState(null);
      const [zoomLevel, setZoomLevel] = React.useState(1);
      const [graphDimensions, setGraphDimensions] = React.useState({ width: 800, height: 600 });
      const fileInputRef = React.useRef(null);
      const svgContainerRef = React.useRef(null);

      const startPosition = { x: 550, y: 100 };
      const circleRadius = 30;
      
      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        setIsLoading(true);
        setError(null);
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const content = e.target.result;
            setXmlContent(content);
            parseXmlPolicy(content);
            setIsLoading(false);
          } catch (err) {
            setError("Failed to read file: " + err.message);
            setIsLoading(false);
          }
        };
        
        reader.onerror = () => {
          setError("Failed to read file");
          setIsLoading(false);
        };
        
        reader.readAsText(file);
      };
      
      function buildTree(journey) {
        const nodes = {};
        
        // Start node
        nodes['start'] = { id: 'start', label: 'Start', children: [] };

        journey.steps.forEach(step => {
          const stepId = `step-${step.order}`;
          const stepNode = {
            id: stepId,
            label: `Step ${step.order}`,
            children: [],
            type: step.type,
            order: step.order,
          };
          nodes[stepId] = stepNode;

          // Link to previous step or start
          const parentId = step.order === 1 ? 'start' : `step-${step.order - 1}`;
          nodes[parentId].children.push(stepNode);

          // Add preconditions as child branches
          if (step.preconditions?.length > 0) {
            step.preconditions.forEach((pre, i) => {
              const condId = `condition-${step.order}-${i}`;
              const condNode = {
                id: condId,
                label: `${pre.type}: ${pre.value}`,
                type: 'condition',
                children: []
              };
              nodes[condId] = condNode;
              stepNode.children.push(condNode);
            });
          }
        });

        // Add end node
        const lastStep = journey.steps[journey.steps.length - 1];
        const lastStepId = `step-${lastStep.order}`;
        const endNode = { id: 'end', label: 'End', type: 'end', children: [] };
        nodes[lastStepId].children.push(endNode);

        console.dir(nodes);
        return nodes['start']; // root of the tree
      }

      function assignPositions(node, depth = 0, xOffset = { current: 0 }, positions = {}) {
        const yStep = 120;
        const xStep = 180;

        const currentX = xOffset.current;
        positions[node.id] = {
          x: currentX * xStep + startPosition.x,
          y: depth * yStep + startPosition.y
        };

        if (node.children.length > 0) {
          node.children.forEach(child => {
            xOffset.current += 1;
            assignPositions(child, depth + 1, xOffset, positions);
          });
        }

        return positions;
      }


      const parseXmlPolicy = (xmlString) => {
        try {
          // Parse XML
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlString, "text/xml");
          
          // Check for parsing errors
          const parserError = xmlDoc.querySelector('parsererror');
          if (parserError) {
            throw new Error("XML parsing error");
          }
          
          // Extract policy metadata
          const policyId = xmlDoc.querySelector('TrustFrameworkPolicy')?.getAttribute('PolicyId') || 'Unknown Policy';
          const tenantId = xmlDoc.querySelector('TrustFrameworkPolicy')?.getAttribute('TenantId') || 'Unknown Tenant';
          const publicPolicyUri = xmlDoc.querySelector('TrustFrameworkPolicy')?.getAttribute('PublicPolicyUri') || '';
          
          // Extract user journeys
          const journeyElements = xmlDoc.querySelectorAll('UserJourney');
          const journeys = Array.from(journeyElements).map(journeyElement => {
            const id = journeyElement.getAttribute('Id');
            
            // Extract orchestration steps
            const steps = Array.from(journeyElement.querySelectorAll('OrchestrationStep')).map(step => {
              const stepOrder = parseInt(step.getAttribute('Order'), 10);
              const stepType = step.querySelector('ClaimsProviderSelections, ClaimsExchange')?.nodeName || 'Unknown';
              const contentElement = step.querySelector('ClaimsProviderSelections, ClaimsExchange');
              
              let details = {};
              if (contentElement) {
                if (contentElement.nodeName === 'ClaimsProviderSelections') {
                  details.selections = Array.from(contentElement.querySelectorAll('ClaimsProviderSelection')).map(selection => ({
                    targetClaimsExchangeId: selection.getAttribute('TargetClaimsExchangeId'),
                    validationClaimsExchangeId: selection.getAttribute('ValidationClaimsExchangeId'),
                  }));
                } else if (contentElement.nodeName === 'ClaimsExchange') {
                  details.id = contentElement.getAttribute('Id');
                  details.type = contentElement.getAttribute('TechnicalProfileReferenceId');
                }
              }
              
              // Extract preconditions
              const preconditions = Array.from(step.querySelectorAll('Precondition')).map(precondition => {
                const type = precondition.getAttribute('Type');
                const value = precondition.querySelector('Value')?.textContent;
                const action = precondition.querySelector('Action')?.textContent;
                
                return {
                  type,
                  value,
                  action
                };
              });
              
              return {
                order: stepOrder,
                type: stepType,
                details,
                preconditions
              };
            });
            
            return {
              id,
              steps: steps.sort((a, b) => a.order - b.order)
            };
          });
          
          // Extract technical profiles (simplified)
          const technicalProfiles = Array.from(xmlDoc.querySelectorAll('TechnicalProfile')).map(profile => ({
            id: profile.getAttribute('Id'),
            displayName: profile.querySelector('DisplayName')?.textContent || profile.getAttribute('Id'),
            protocol: profile.querySelector('Protocol')?.getAttribute('Name') || 'Unknown',
            type: getProfileType(profile)
          }));
          
          const policyInfo = {
            id: policyId,
            tenantId,
            publicPolicyUri,
            technicalProfiles,
            journeys
          };
          
          setPolicyData(policyInfo);
          setUserJourneys(journeys);
          
          if (journeys.length > 0) {
            setActiveJourney(journeys[0].id);
          }
          
        } catch (err) {
          setError("Failed to parse XML policy: " + err.message);
          setPolicyData(null);
          setUserJourneys([]);
          setActiveJourney(null);
        }
      };

      const getProfileType = (profileElement) => {
        // Simple logic to determine profile type
        if (profileElement.querySelector('DisplayClaims')) {
          return 'DisplayClaims';
        } else if (profileElement.querySelector('OutputClaims')) {
          return 'OutputClaims';
        } else {
          return 'Other';
        }
      };
      
      const downloadSvg = () => {
        const svgElement = document.querySelector('.journey-visualization svg');
        if (!svgElement) return;
        
        const svgData = new XMLSerializer().serializeToString(svgElement);
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `${activeJourney || 'journey'}-visualization.svg`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };
      
      // Function to fit graph in view
      const fitGraphToView = () => {
        setZoomLevel(1);
        if (svgContainerRef.current) {
          svgContainerRef.current.scrollLeft = 0;
        }
      };
      
      // Function to calculate graph dimensions
      const calculateGraphDimensions = (nodes) => {
        if (!nodes || nodes.length === 0) return { width: 800, height: 600 };
        
        const xStep = 180;
        const yStep = 100;
        const padding = 100;
        const calculatedWidth = padding * 2 + xStep * (nodes.length - 1);
        const calculatedHeight = padding * 2 + yStep * (nodes.length - 1);
        
        return {
          width: Math.max(800, calculatedWidth), // Ensure minimum width
          height: calculatedHeight
        };
      };
      
      React.useEffect(() => {
        if (activeJourney && policyData) {
          const journey = userJourneys.find(j => j.id === activeJourney);
          if (journey) {
            // Create graph nodes
            const nodes = [{ id: 'start', label: 'Start', type: 'start' }];
            
            // Process each step
            journey.steps.forEach(step => {
              const nodeId = `step-${step.order}`;
              nodes.push({ id: nodeId, label: `Step ${step.order}`, type: step.type, order: step.order });
              
              // Add condition nodes if any
              if (step.preconditions && step.preconditions.length > 0) {
                step.preconditions.forEach((precondition, idx) => {
                  const conditionId = `condition-${step.order}-${idx}`;
                  nodes.push({ id: conditionId, label: `Condition`, type: 'condition' });
                });
              }
            });
            
            // End node
            nodes.push({ id: 'end', label: 'End', type: 'end' });
            
            // Calculate dimensions and update state
            const dimensions = calculateGraphDimensions(nodes);
            setGraphDimensions(dimensions);
          }
        }
      }, [activeJourney, policyData, userJourneys]);
      
      const renderJourneyVisualization = () => {
        if (!policyData || !activeJourney) return null;
        
        const journey = userJourneys.find(j => j.id === activeJourney);
        if (!journey) return null;
        
        // Create graph nodes and links
        const nodes = [];
        const links = [];
        
        // Start node
        nodes.push({ id: 'start', label: 'Start', type: 'start' });
        
        // Process each step
        journey.steps.forEach(step => {
          const nodeId = `step-${step.order}`;
          let label = `Step ${step.order}`;
          
          if (step.type === 'ClaimsExchange') {
            const profileId = step.details.type;
            const profile = policyData.technicalProfiles.find(p => p.id === profileId);
            if (profile) {
              label += `: ${profile.displayName || profileId}`;
            } else {
              label += `: ${profileId || 'Unknown'}`;
            }
          } else {
            label += ': Provider Selection';
          }
          
          nodes.push({ 
            id: nodeId, 
            label: label, 
            type: step.type,
            details: step.details,
            order: step.order
          });
          
          // Connect to previous step or start
          if (step.order === 1) {
            links.push({ source: 'start', target: nodeId });
          } else {
            links.push({ source: `step-${step.order - 1}`, target: nodeId });
          }
          
          // Handle preconditions (branching)
          if (step.preconditions && step.preconditions.length > 0) {
            step.preconditions.forEach((precondition, idx) => {
              const conditionId = `condition-${step.order}-${idx}`;
              nodes.push({ 
                id: conditionId, 
                label: `${precondition.type}: ${precondition.value}`, 
                type: 'condition'
              });
              
              links.push({ 
                source: nodeId, 
                target: conditionId, 
                label: precondition.action || 'Skip' 
              });
            });
          }
        });
        
        // Node positions
        const positions = assignPositions(buildTree(journey));

        // End node
        const lastStepId = `step-${journey.steps[journey.steps.length - 1].order}`;
        nodes.push({ id: 'end', label: 'End', type: 'end' });
        links.push({ source: lastStepId, target: 'end' });
        
        // Render SVG using D3
        return (
          <div 
            className="journey-visualization bg-gray-50 rounded-lg p-4" 
            ref={svgContainerRef}
            style={{ maxHeight: '600px' }}
          >
            <svg 
              width={graphDimensions.width} 
              height={graphDimensions.height} 
              className="transform origin-center"
              style={{ transform: `scale(${zoomLevel})` }}
            >
              <g className="links">
                {links.map((link, i) => {
                  const sourceNode = nodes.find(n => n.id === link.source);
                  const targetNode = nodes.find(n => n.id === link.target);

                  const sourcePos = positions[link.source];
                  const targetPos = positions[link.target];
                  
                  // Simple layout logic (linear horizontal layout)
                  const yStep = 120;
                  const xOffset = 400;

                  const sourceIndex = nodes.indexOf(sourceNode);
                  const targetIndex = nodes.indexOf(targetNode);

                  const x1 = xOffset;
                  const y1 = 100 + sourceIndex * yStep;
                  const x2 = xOffset;
                  const y2 = 100 + targetIndex * yStep;

                  return (
                    <g key={`link-${i}`}>
                      <line 
                        // x1={x1} y1={y1} x2={x2} y2={y2}
                        x1={sourcePos.x} y1={sourcePos.y}
                        x2={targetPos.x - circleRadius} y2={targetPos.y - circleRadius / 2}
                        stroke="#666" 
                        strokeWidth="2"
                        markerEnd="url(#arrowhead)"
                      />
                      {link.label && (
                        <text 
                          x={(sourcePos.x + targetPos.x) / 2} 
                          y={(sourcePos.y + targetPos.y) / 2 - 10}
                          textAnchor="middle"
                          fontSize="12"
                          fill="#666"
                        >
                          {link.label}
                        </text>
                      )}
                    </g>
                  );
                })}
              </g>
              
              <g className="nodes">
                {nodes.map((node, i) => {
                  // Simple layout logic (linear horizontal layout)
                  // const x = 400; // fixed horizontal center
                  // const y = 100 + i * 120; // vertical stacking
                  
                  const { x, y } = positions[node.id] || { x: 0, y: 0 };
                  
                  let nodeColor = '#6366f1'; // Default (indigo)
                  if (node.type === 'start') nodeColor = '#10b981'; // Green
                  if (node.type === 'end') nodeColor = '#ef4444'; // Red
                  if (node.type === 'condition') nodeColor = '#f59e0b'; // Amber
                  
                  return (
                    <g key={`node-${i}`} className="node" transform={`translate(${x}, ${y})`}>
                      <circle 
                        r={circleRadius}
                        fill={nodeColor}
                        stroke="#fff"
                        strokeWidth="2"
                      />
                      
                      <text 
                        textAnchor="middle" 
                        dominantBaseline="middle"
                        fill="#fff"
                        fontSize="12"
                        fontWeight="bold"
                      >
                        {node.id === 'start' ? 'Start' : 
                         node.id === 'end' ? 'End' : 
                         node.order || ''}
                      </text>
                      
                      <text 
                        y="50" 
                        textAnchor="middle" 
                        fontSize="12"
                        width="150"
                        className="node-label"
                      >
                        {node.label.length > 20 ? node.label.substring(0, 20) + '...' : node.label}
                      </text>
                      <title>{node.label}</title>
                    </g>
                  );
                })}
              </g>
              
              <defs>
                <marker 
                  id="arrowhead" 
                  viewBox="0 0 10 10" 
                  refX="8" refY="5"
                  markerWidth="6" markerHeight="6"
                  orient="auto"
                >
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#666" />
                </marker>
              </defs>
            </svg>
          </div>
        );
      };
      
      return (
        <div className="flex flex-col space-y-6 p-4 w-full max-w-6xl mx-auto">
          <div className="bg-indigo-700 text-white p-4 rounded-lg shadow-lg">
            <h1 className="text-2xl font-bold">Azure B2C Policy Visualizer</h1>
            <p className="text-indigo-100">
              Upload your custom policy XML files to visualize user journeys and understand policy flow
            </p>
          </div>
          
          <div className="flex flex-col space-y-4">
            <div className="flex items-center space-x-4 flex-wrap gap-2">
              <button 
                className="bg-indigo-600 hover-bg-indigo-700 text-white px-4 py-2 rounded-lg flex items-center space-x-2"
                onClick={() => fileInputRef.current?.click()}
              >
                <IconComponents.Upload size={16} />
                <span>Upload Policy XML</span>
              </button>
              
              <input 
                type="file" 
                accept=".xml"
                className="hidden" 
                ref={fileInputRef}
                onChange={handleFileUpload}
              />
              
              {policyData && (
                <button 
                  className="bg-gray-600 hover-bg-gray-700 text-white px-4 py-2 rounded-lg flex items-center space-x-2"
                  onClick={downloadSvg}
                >
                  <IconComponents.Download size={16} />
                  <span>Download SVG</span>
                </button>
              )}
              
              {policyData && (
                <div className="flex items-center space-x-2">
                  <button 
                    className="bg-gray-200 hover-bg-gray-300 p-2 rounded-lg"
                    onClick={() => setZoomLevel(prev => Math.max(0.5, prev - 0.1))}                    
                    title="Zoom Out"
                  >
                    <IconComponents.ZoomOut size={16} />
                  </button>
                  <span className="text-sm font-medium">{Math.round(zoomLevel * 100)}%</span>
                  <button 
                    className="bg-gray-200 hover-bg-gray-300 p-2 rounded-lg"
                    onClick={() => setZoomLevel(prev => Math.min(2, prev + 0.1))}
                    title="Zoom In"
                  >
                    <IconComponents.ZoomIn size={16} />
                  </button>
                  <button
                    className="bg-gray-200 hover-bg-gray-300 p-2 rounded-lg ml-2"
                    onClick={fitGraphToView}
                    title="Fit to View"
                  >
                    <IconComponents.FitWidth size={16} />
                  </button>
                </div>
              )}
            </div>
            
            {isLoading && (
              <div className="flex items-center justify-center p-6">
                <IconComponents.RefreshCw className="animate-spin mr-2" size={20} />
                <span>Processing policy file...</span>
              </div>
            )}
            
            {error && (
              <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded">
                <p className="font-bold">Error</p>
                <p>{error}</p>
              </div>
            )}
            
            {policyData && (
              <div className="bg-white rounded-lg shadow-md p-4">
                <div className="mb-4">
                  <h2 className="text-xl font-semibold">Policy Details</h2>
                  <p className="text-gray-600">ID: {policyData.id}</p>
                  <p className="text-gray-600">Tenant: {policyData.tenantId}</p>
                </div>
                
                <div className="mb-6">
                  <h3 className="text-lg font-medium mb-2">User Journeys</h3>
                  {userJourneys.length > 0 ? (
                    <div className="flex flex-wrap gap-2">
                      {userJourneys.map(journey => (
                        <button
                          key={journey.id}
                          className={`px-4 py-2 rounded-lg ${
                            activeJourney === journey.id 
                              ? 'bg-indigo-600 text-white' 
                              : 'bg-gray-200 hover:bg-gray-300 text-gray-800'
                          }`}
                          onClick={() => setActiveJourney(journey.id)}
                        >
                          {journey.id}
                        </button>
                      ))}
                    </div>
                  ) : (
                    <p className="text-gray-500">No user journeys found in policy</p>
                  )}
                </div>
                
                {activeJourney && (
                  <div>
                    <h3 className="text-lg font-medium mb-2">
                      Journey: {activeJourney}
                    </h3>
                    {renderJourneyVisualization()}
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      );
    };
    
    // Render the app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<AzureB2CPolicyVisualizer />);
  </script>
</body>
</html>